# -*- coding: utf-8 -*-
"""2.LinearReg(boston).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_AWnHhEU6hQb814NsODZN3F8Lh2jVXa2
"""

# Linear Regression으로 Boston Housing 데이터를 학습한다.
# ------------------------------------------------------
import numpy as np
from sklearn.datasets import load_boston
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
from sklearn.preprocessing import StandardScaler

# Boston housing data set을 읽어온다
boston = load_boston()

# 데이터를 표준화한다. train과 test 데이터를 동시에 표준화 했다.
# 괜찮을까? 문제라면 무엇이 문제일까?
f_scale = StandardScaler()
t_scale = StandardScaler()

f_scaled = f_scale.fit_transform(boston.data)
t_scaled = t_scale.fit_transform(boston.target.reshape(-1,1))

# Train 데이터 세트와 Test 데이터 세트를 구성한다
x_train, x_test, y_train, y_test = train_test_split(f_scaled, t_scaled, test_size = 0.2)

# Logistic Regression으로 Train 데이터 세트를 학습한다.
model = LinearRegression()
model.fit(x_train, y_train)

# x_test[n]에 해당하는 target (price)을 추정한다.
n = 1
y_pred = model.predict(x_test[n].reshape(1, -1))

y_pred

# 복원
y_pred = t_scale.inverse_transform(y_pred)
y_true = t_scale.inverse_transform(y_test[n].reshape(-1, 1))

print('test[%d]의 추정 price = %.2f' % (n, y_pred))
print('test[%d]의 실제 price = %.2f' % (n, y_true))
print('추정 오류 = rmse(추정 price - 실제 price) = %.2f' % np.sqrt(np.square(y_pred - y_true)))

# 시험 데이터 전체의 오류를 MSE로 표시한다.
# MSE는 값의 범위가 크다는 단점이 있다.
y_pred = model.predict(x_test)
y_pred = t_scale.inverse_transform(y_pred)
y_true = t_scale.inverse_transform(y_test)

rmse = (np.sqrt(mean_squared_error(y_test, y_pred)))
print('시험 데이터 전체 오류 (rmse) = %.4f' % rmse)

# 시험 데이터 전체의 오류를 R-square로 표시한다.
# 범위가 한정되어 MSE보다 좋은 척도다.
print('시험 데이터 전체 오류 (R2-score) = %.4f' % model.score(x_test, y_test))

y_pred

# 추정 결과를 시각화 한다.
plt.figure(figsize=(6, 6))
plt.scatter(y_true, y_pred, c='red', s=30, alpha=0.5)
plt.xlabel("house price")
plt.ylabel("predicted price")
plt.show()

