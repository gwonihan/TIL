# -*- coding: utf-8 -*-
"""12.santander(LGBM).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EPVzXGFXNg0fNNMd9JcJaRf9Rh2mOY7C
"""

import pandas as pd
from lightgbm import LGBMClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.metrics import roc_auc_score, roc_curve
from sklearn.model_selection import train_test_split
import matplotlib.pyplot as plt
import pickle

DATA_PATH = '/content/drive/My Drive/Colab Notebooks/data/'

# There are no missing values in this dataset, it looks like that Santander 
# already cleaned and preprocessed the data.
# df.shape = (76020, 370)
df = pd.read_csv(DATA_PATH + "santander.csv", encoding='latin-1')

df.head()
# df.info()
# df.describe()
# df['TARGET'].value_counts()
# df['var3'].value_counts()

# target의 분포를 확인한다.
df['TARGET'].value_counts().plot.bar()

# 'var3' feature의 -999999를 2로 치환하고, 'ID' feature는 drop한다.
df['var3'].replace(-999999, 2, inplace=True)
df.drop('ID', axis = 1, inplace=True)

# 피처와 레이블 세트를 분리하고, 학습/평가/시험 데이터를 생성한다.
x_feat = df.drop('TARGET', axis=1)
y_target = df['TARGET']

x_train, x_test, y_train, y_test = train_test_split(x_feat, y_target, test_size = 0.2, stratify=y_target)

# 레이블 분포가 고른지 확인한다. 고르지 않다. accuracy로 평가하는 것보다 ROC-AUC로 평가하는 것이 적합하다.
print(y_train.value_counts() / len(y_train))
print()
print(y_test.value_counts() / len(y_test))

# 모델 생성
model = LGBMClassifier(n_estimators = 100, boosting="goss", top_rate=0.2, other_rate=0.1, is_unbalance = True)

# 학습
params = {'max_depth' : [20, 30, 50, 100]}

# cv가 integer이면 StratifiedKFold로 동작한다. target의 분포가 매우 불균형하기 때문에 stratified가 필요하다.
# Document 내용 : For integer/None inputs, if the estimator is a classifier and y is either binary or 
# multiclass, StratifiedKFold is used.
grid = GridSearchCV(model, param_grid = params, cv = 3, scoring ="roc_auc")
grid.fit(x_train, y_train)

print('GridSearchCV 최적 파라메터 :', grid.best_params_)

# 평가 (AUC)
y_pred = grid.predict_proba(x_test)[:, 1]
auc = roc_auc_score(y_test, y_pred)

print("ROC AUC = {0:.4f}".format(auc))

# ROC curve를 그린다
fprs, tprs, thresholds = roc_curve(y_test, y_pred)

plt.plot(fprs, tprs, label = 'ROC')
plt.plot([0,1], [0,1], '--', label = 'Random')
plt.legend()
plt.xlabel('FPR')
plt.ylabel('TPR')
plt.show()

